<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ESD – Slope thresholds by aspect (prototype)</title>

  <!-- Highcharts (CDN) -->
  <script src="https://code.highcharts.com/highcharts.js"></script>
  <script src="https://code.highcharts.com/highcharts-more.js"></script>

  <style>
    :root{
      --bg:#ffffff;
      --panel:#ffffff;
      --border:#e6e8ef;
      --text:#0f172a;
      --muted:#64748b;
      --btn:#0b5fff;
      --btnText:#ffffff;
      --chip:#f1f5f9;
      --shadow:0 12px 30px rgba(15,23,42,.10);

      /* band colors (approx Solargis-like on white) */
      --red:#cc2929;
      --orange:#ff5201;
      --yellow:#fdb022;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background:var(--bg);
      color:var(--text);
    }

    /* Simulated right side panel: 480px + padding */
    .side-panel{
      width:480px;
      padding:16px;
      border-left:1px solid var(--border);
      min-height:100vh;
      margin-left:auto;
      background:var(--panel);
    }

    .card{
      border:1px solid var(--border);
      border-radius:14px;
      box-shadow:var(--shadow);
      background:#fff;
      overflow:hidden;
    }
    .card + .card{ margin-top:12px; }

    .header{
      padding:12px 14px;
      border-bottom:1px solid var(--border);
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
    }
    .title{ font-weight:800; font-size:14px; }
    .subtitle{ margin-top:4px; font-size:12px; color:var(--muted); line-height:1.35; }

    .content{ padding:12px 14px; }

    .row{ display:flex; align-items:center; justify-content:space-between; gap:10px; margin:10px 0; }
    .row label{ font-size:13px; color:var(--text); }
    .row .right{ display:flex; align-items:center; gap:10px; }

    /* Simple switch */
    .switch{ position:relative; display:inline-block; width:42px; height:24px; }
    .switch input{ opacity:0; width:0; height:0; }
    .slider{ position:absolute; cursor:pointer; inset:0; background:#e2e8f0; border:1px solid var(--border); transition:.15s; border-radius:999px; }
    .slider:before{ position:absolute; content:""; height:18px; width:18px; left:3px; top:2px; background:#fff; border:1px solid rgba(15,23,42,.10); transition:.15s; border-radius:50%; }
    .switch input:checked + .slider{ background:rgba(11,95,255,.18); border-color:rgba(11,95,255,.35); }
    .switch input:checked + .slider:before{ transform:translateX(18px); }
    .switch input:focus-visible + .slider{ box-shadow:0 0 0 3px rgba(11,95,255,.10); }
    input[type="number"]{
      width:160px;
      padding:9px 10px;
      border:1px solid var(--border);
      border-radius:10px;
      background:#fff;
      color:var(--text);
      outline:none;
    }
    input[type="number"]:focus{
      border-color:rgba(11,95,255,.45);
      box-shadow:0 0 0 3px rgba(11,95,255,.10);
    }

    .btns{ display:flex; flex-wrap:wrap; gap:8px; }
    button{
      border:1px solid var(--border);
      background:#fff;
      color:var(--text);
      padding:9px 10px;
      border-radius:10px;
      cursor:pointer;
      font-weight:700;
      font-size:13px;
    }
    button.primary{
      border-color:rgba(11,95,255,.25);
      background:rgba(11,95,255,.08);
    }
    button.active{
      border-color:rgba(11,95,255,.45);
      background:rgba(11,95,255,.12);
    }
    button.cta{
      border-color:var(--btn);
      background:var(--btn);
      color:var(--btnText);
    }

    .chip{
      display:inline-flex;
      align-items:center;
      padding:6px 10px;
      border-radius:999px;
      background:var(--chip);
      border:1px solid var(--border);
      color:var(--muted);
      font-size:12px;
      user-select:none;
      white-space:nowrap;
    }

    #previewChart{
      width:100%;
      height:320px;
    }

    /* Modal dialog */
    .modal-backdrop{
      position:fixed;
      inset:0;
      background:rgba(15,23,42,.45);
      display:none;
      align-items:center;
      justify-content:center;
      padding:24px;
      z-index:9999;
    }
    .modal{
      width:min(1040px, 96vw);
      background:#fff;
      border:1px solid var(--border);
      border-radius:16px;
      box-shadow:0 24px 60px rgba(15,23,42,.25);
      overflow:hidden;
    }
    .modal-grid{
      display:grid;
      grid-template-columns: 1.6fr 1fr;
      gap:0;
    }
    .modal-left{ padding:14px; border-right:1px solid var(--border); }
    .modal-right{ padding:14px; }

    #editorChart{ height:560px; }

    .modal-footer{
      display:flex;
      justify-content:flex-end;
      gap:10px;
      padding:12px 14px;
      border-top:1px solid var(--border);
      background:#fff;
    }

    .hint{ font-size:12px; color:var(--muted); line-height:1.35; }

    @media (max-width: 980px){
      .modal-grid{ grid-template-columns:1fr; }
      .modal-left{ border-right:none; border-bottom:1px solid var(--border); }
      #editorChart{ height:420px; }
    }
  </style>
</head>
<body>

  <div class="side-panel">

    <div class="card">
      <div class="header">
        <div>
          <div class="title">Slope thresholds by aspect</div>
          <div class="subtitle">Preview of the current profile. Edit opens an advanced dialog.</div>
        </div>
        <div class="chip">North-up • polar</div>
      </div>
      <div class="content">
        <div id="previewChart"></div>
        <div class="btns" style="margin-top:10px; justify-content:flex-end;">
          <button class="cta" id="openEditor">Edit…</button>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="header">
        <div>
          <div class="title">Severity bands</div>
          <div class="subtitle">Bands are derived from offsets from the red (hard limit) curve.</div>
        </div>
      </div>
      <div class="content">
        <div class="row">
          <label for="deltaOrange">Orange band</label>
          <div class="right">
            <input id="deltaOrange" type="number" min="0" step="0.5" value="3" aria-label="Orange offset (Δ1)" />
            <label class="switch" title="Toggle orange band">
              <input id="toggleOrange" type="checkbox" checked />
              <span class="slider"></span>
            </label>
          </div>
        </div>
        <div class="row">
          <label for="deltaYellow">Yellow band</label>
          <div class="right">
            <input id="deltaYellow" type="number" min="0" step="0.5" value="6" aria-label="Yellow offset (Δ2)" />
            <label class="switch" title="Toggle yellow band">
              <input id="toggleYellow" type="checkbox" checked />
              <span class="slider"></span>
            </label>
          </div>
        </div>
        <div class="hint">Offsets: Orange = Red − Δ1, Yellow = Red − Δ2</div>
      </div>
    </div>

  </div>

  <!-- Modal dialog (advanced editor) -->
  <div class="modal-backdrop" id="modalBackdrop" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-label="Edit slope thresholds by aspect">
      <div class="header">
        <div>
          <div class="title">Edit thresholds by aspect</div>
          <div class="subtitle">Drag red points to adjust the hard limit.</div>
        </div>
        <div class="chip">Snap: 0.1° • <span id="dragReadout">Value: <b id="dragValue">—</b>°</span></div>
      </div>

      <div class="modal-grid">
        <div class="modal-left">
          <div id="editorChart"></div>
        </div>
        <div class="modal-right">
          <div class="card" style="box-shadow:none;">
            <div class="header">
              <div>
                <div class="title">Editing</div>
                <div class="subtitle">Keep it simple: start with a preset, then tweak a few directions.</div>
              </div>
            </div>
            <div class="content">
              <div class="btns" style="margin-top:12px;">
                <button id="presetUniform" data-preset="uniform">Uniform</button>
                <button id="presetSouthTolerant" data-preset="south">South tolerant</button>
                <button id="presetNorthStrict" data-preset="north">North strict</button>
                <button id="mirrorNS">Mirror N↔S</button>
                <button id="reset" data-preset="reset">Reset</button>
              </div>

              <div class="hint" style="margin-top:10px;">
                Ring labels (0, 5, 10, …) are shown on N / E / S / W spokes as requested.
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="modal-footer">
        <button id="cancel">Cancel</button>
        <button class="cta" id="apply">Apply</button>
      </div>
    </div>
  </div>

<script>
  // ---- Model ----
  const MAX_DEG = 25;

  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
  function snapValue(value, step){
    if (!step || step <= 0) return value;
    return Math.round(value / step) * step;
  }

  function makeClosed(points8){
    const first = points8[0];
    const closed = points8.slice();
    closed.push([360, first[1]]);
    return closed;
  }

  const defaultRed8 = [
    [0, 6], [45, 7], [90, 9], [135, 10], [180, 12], [225, 10], [270, 9], [315, 7]
  ];

  let redData = makeClosed(defaultRed8);
  let redDataStaged = null; // used while modal is open

  // Band visibility
  let showOrange = true;
  let showYellow = true;

  function getDeltas(){
    const d1 = parseFloat(document.getElementById('deltaOrange').value || '0');
    const d2 = parseFloat(document.getElementById('deltaYellow').value || '0');
    return { d1: Math.max(0, d1), d2: Math.max(0, d2) };
  }

  function deriveBands(baseRed){
    const { d1, d2 } = getDeltas();
    const orange = baseRed.map(([a, v]) => [a, clamp(v - d1, 0, MAX_DEG)]);
    const yellow = baseRed.map(([a, v]) => [a, clamp(v - d2, 0, MAX_DEG)]);
    return { orange, yellow };
  }

  function toRange(lowSeries, highSeries){
    // Builds Highcharts arearange points: [angle, low, high]
    const n = Math.min(lowSeries.length, highSeries.length);
    const out = [];
    for (let i = 0; i < n; i++){
      out.push([lowSeries[i][0], lowSeries[i][1], highSeries[i][1]]);
    }
    return out;
  }

  function toOuterRange(innerSeries){
    // From curve to MAX_DEG (outer ring)
    return innerSeries.map(([a, v]) => [a, v, MAX_DEG]);
  }

  function applyBandVisibility(chart){
    if (!chart) return;
    const lineOrange = chart.get('lineOrange');
    const lineYellow = chart.get('lineYellow');
    const fillOrange = chart.get('fillOrange');
    const fillYellow = chart.get('fillYellow');

    if (lineOrange) lineOrange.setVisible(!!showOrange, false);
    if (fillOrange) fillOrange.setVisible(!!showOrange, false);
    if (lineYellow) lineYellow.setVisible(!!showYellow, false);
    if (fillYellow) fillYellow.setVisible(!!showYellow, false);

    chart.redraw(false);
  }

  // ---- Custom ring labels: show 0/5/10/… on N/E/S/W spokes ----
  function addRingLabels(chart){
    const yAxis = chart.yAxis[0];
    const pane = chart.pane[0];
    if (!pane || !pane.center) return;

    // clean previous
    chart.customRingLabels = chart.customRingLabels || [];
    while (chart.customRingLabels.length) {
      const el = chart.customRingLabels.pop();
      try { el.destroy(); } catch(e) {}
    }

    const cx = chart.plotLeft + pane.center[0];
    const cy = chart.plotTop + pane.center[1];
    const radius = pane.center[2] / 2;

    const min = yAxis.min;
    const max = yAxis.max;

    const ticks = yAxis.tickPositions || [];

    for (const t of ticks){
      // Hide the outermost ring label (e.g., 25°) to avoid overlaps with axis labels and UI.
      if (t === max) continue;
      // Hide 0° ring label (too much visual noise).
      if (t === 0) continue;
      const r = (t - min) / (max - min) * radius;
      const txt = `${t}`;

      const positions = [
        { x: cx, y: cy - r, align: 'center', va: 'middle' }, // N
        { x: cx + r, y: cy, align: 'left', va: 'middle' },   // E
        { x: cx, y: cy + r, align: 'center', va: 'middle' }, // S
        { x: cx - r, y: cy, align: 'right', va: 'middle' }   // W
      ];

      for (const p of positions){
        // small offset to avoid sitting exactly on gridline
        const ox = (p.align === 'left') ? 6 : (p.align === 'right' ? -6 : 0);
        const oy = (p.y < cy) ? -6 : (p.y > cy ? 6 : 0);

        const label = chart.renderer
          .text(txt, p.x + ox, p.y + oy)
          .css({
            color: '#64748b',
            fontSize: '11px'
          })
          .attr({
            zIndex: 8
          })
          .add();

        // center alignment tweak
        const bbox = label.getBBox();
        let tx = p.x + ox;
        let ty = p.y + oy;
        if (p.align === 'center') tx -= bbox.width / 2;
        if (p.va === 'middle') ty += bbox.height / 4;

        label.attr({ x: tx, y: ty });
        chart.customRingLabels.push(label);
      }
    }
  }

  // ---- Chart factory ----
  function createPolarChart(containerId, options){
    const editable = !!options.editable;
    const baseRed = options.data;
    const bands = deriveBands(baseRed);

    // Area fills representing the same "outside" classification as the terrain mesh
    // (fills are OUTSIDE the curves, up to MAX_DEG)
    const fillYellow = toRange(bands.yellow, bands.orange);
    const fillOrange = toRange(bands.orange, baseRed);
    const fillRed = toOuterRange(baseRed);

    return Highcharts.chart(containerId, {
      chart: {
        polar: true,
        backgroundColor: 'transparent',
        spacing: [10, 10, 10, 10],
        events: {
          render: function(){
            addRingLabels(this);
          }
        }
      },
      title: { text: null },
      pane: {
        // 0° is North (top)
        startAngle: 0,
        endAngle: 360
      },
      xAxis: {
        min: 0,
        max: 360,
        tickInterval: 45,
        labels: {
          formatter: function(){
            const v = (this.value % 360 + 360) % 360;
            const map = {0:'N',45:'NE',90:'E',135:'SE',180:'S',225:'SW',270:'W',315:'NW',360:'N'};
            return map[v] ?? v;
          },
          style: { color: '#64748b', fontSize: '11px' }
        },
        lineColor: 'rgba(100,116,139,.35)',
        gridLineColor: 'rgba(100,116,139,.18)',
        gridZIndex: 6,
        tickColor: 'rgba(100,116,139,.35)'
      },
      yAxis: {
        min: 0,
        max: MAX_DEG,
        tickInterval: 5,
        labels: { enabled: false }, // we render custom labels on N/E/S/W
        gridLineColor: 'rgba(100,116,139,.18)',
        gridZIndex: 6
      },
      legend: { enabled: false },
      tooltip: {
        backgroundColor: '#ffffff',
        borderColor: 'rgba(15,23,42,.14)',
        style: { color: '#0f172a' },
        formatter: function(){
          const a = (this.x % 360 + 360) % 360;
          const dirMap = {0:'N',45:'NE',90:'E',135:'SE',180:'S',225:'SW',270:'W',315:'NW'};
          const dir = dirMap[a] ?? `${a.toFixed(0)}°`;
          return `<b>${this.series.name}</b><br/>Aspect: <b>${dir}</b><br/>Limit: <b>${this.y.toFixed(1)}°</b>`;
        }
      },
      plotOptions: {
        series: {
          animation: false,
          pointPlacement: 'on',
          enableMouseTracking: true
        }
      },
      series: [
        // Fills (subtle translucency so gridlines remain visible)
        {
          id: 'fillRed',
          name: 'Red fill',
          type: 'arearange',
          data: fillRed,
          color: 'rgba(204,41,41,0.40)',
          lineWidth: 0,
          marker: { enabled: false },
          enableMouseTracking: false,
          zIndex: 1
        },
        {
          id: 'fillOrange',
          name: 'Orange fill',
          type: 'arearange',
          data: fillOrange,
          color: 'rgba(255,82,1,0.40)',
          lineWidth: 0,
          marker: { enabled: false },
          enableMouseTracking: false,
          zIndex: 2
        },
        {
          id: 'fillYellow',
          name: 'Yellow fill',
          type: 'arearange',
          data: fillYellow,
          color: 'rgba(253,176,34,0.40)',
          lineWidth: 0,
          marker: { enabled: false },
          enableMouseTracking: false,
          zIndex: 3
        },

        // Lines
        {
          id: 'lineRed',
          name: 'Red (hard limit)',
          type: 'line',
          data: baseRed,
          color: getComputedStyle(document.documentElement).getPropertyValue('--red').trim(),
          lineWidth: 3,
          marker: {
            enabled: editable,
            radius: editable ? 7 : 0,
            symbol: 'circle',
            lineColor: '#ffffff',
            lineWidth: 1
          },
          stickyTracking: !editable,
          zIndex: 10
        },
        {
          id: 'lineOrange',
          name: 'Orange (warning)',
          type: 'line',
          data: bands.orange,
          color: getComputedStyle(document.documentElement).getPropertyValue('--orange').trim(),
          lineWidth: 2,
          dashStyle: 'ShortDash',
          marker: { enabled: false },
          enableMouseTracking: false,
          zIndex: 9
        },
        {
          id: 'lineYellow',
          name: 'Yellow (caution)',
          type: 'line',
          data: bands.yellow,
          color: getComputedStyle(document.documentElement).getPropertyValue('--yellow').trim(),
          lineWidth: 2,
          dashStyle: 'ShortDot',
          marker: { enabled: false },
          enableMouseTracking: false,
          zIndex: 8
        }
      ],
      credits: { enabled: false }
    });
  }

  // ---- Manual dragging for the editor chart ----
  function attachManualDrag(chart){
    const dragValueEl = document.getElementById('dragValue');

    function dirLabelFromAngle(angle){
      const a = ((angle % 360) + 360) % 360;
      const dirMap = {0:'N',45:'NE',90:'E',135:'SE',180:'S',225:'SW',270:'W',315:'NW',360:'N'};
      return dirMap[a] ?? `${a.toFixed(0)}°`;
    }

    function showDragReadout(point){
      if (!dragValueEl) return;
      dragValueEl.textContent = point.y.toFixed(1).replace(/\.0$/, '');

      // Show Highcharts tooltip pinned to the currently dragged point.
      try { chart.tooltip.refresh(point); } catch(e) {}
    }

    function clearDragReadout(){
      if (!dragValueEl) return;
      dragValueEl.textContent = '—';
      try { chart.tooltip.hide(0); } catch(e) {}
    }

    // Preset highlighting: whenever the user drags, we treat the profile as "Custom".
    function clearPresetHighlight(){
      document.querySelectorAll('[data-preset]').forEach(b => b.classList.remove('active'));
    }
    // Preset highlighting: whenever the user drags, we treat the profile as "Custom".
    function clearPresetHighlight(){
      document.querySelectorAll('[data-preset]').forEach(b => b.classList.remove('active'));
    }
    let draggingPoint = null;

    function getSnapStepFromEvent(ev){
      // Fixed snap step (UI removed)
      return 0.1;
    }

    function setPointY(point, newY, ev){
      const step = getSnapStepFromEvent(ev);
      const snapped = snapValue(newY, step);
      const y = clamp(snapped, 0, MAX_DEG);
      point.update(y, false);
    }

    function syncClosedPoint(){
      const s = chart.get('lineRed');
      if (!s || !s.points || s.points.length < 2) return;
      const first = s.points[0].y;
      const lastIdx = s.points.length - 1;
      s.points[lastIdx].update(first, false);
    }

    function recomputeBands(){
      const redLine = chart.get('lineRed');
      const red = redLine.data.map(p => [p.x, p.y]);
      const { orange, yellow } = deriveBands(red);

      const lineOrange = chart.get('lineOrange');
      const lineYellow = chart.get('lineYellow');
      const fillRedS = chart.get('fillRed');
      const fillOrangeS = chart.get('fillOrange');
      const fillYellowS = chart.get('fillYellow');

      if (lineOrange) lineOrange.setData(orange, false);
      if (lineYellow) lineYellow.setData(yellow, false);
      if (fillYellowS) fillYellowS.setData(toRange(yellow, orange), false);
      if (fillOrangeS) fillOrangeS.setData(toRange(orange, red), false);
      if (fillRedS) fillRedS.setData(toOuterRange(red), false);

      applyBandVisibility(chart);
    }

    function findClosestRedPoint(e){
      const normalized = chart.pointer.normalize(e);
      return chart.get('lineRed').searchPoint(normalized, true);
    }

    function getAxisValues(e){
      const normalized = chart.pointer.normalize(e);
      const coords = chart.pointer.getCoordinates(normalized);
      const yVal = coords && coords.yAxis && coords.yAxis[0] ? coords.yAxis[0].value : null;
      return { y: yVal };
    }

    const el = chart.container;

    el.addEventListener('pointerdown', (e) => {
      const p = findClosestRedPoint(e);
      if (!p) return;

      const n = chart.pointer.normalize(e);
      const dx = p.plotX - n.chartX;
      const dy = p.plotY - n.chartY;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist > 18) return;

      draggingPoint = p;
      showDragReadout(p);
      el.setPointerCapture(e.pointerId);
      e.preventDefault();
    });

    el.addEventListener('pointermove', (e) => {
      if (!draggingPoint) return;
      clearPresetHighlight();
      const { y } = getAxisValues(e);
      if (y == null || Number.isNaN(y)) return;
      setPointY(draggingPoint, y, e);
      syncClosedPoint();
      recomputeBands();
      // Update live value readout after snapping.
      showDragReadout(draggingPoint);
    });

    function finishDrag(){
      if (!draggingPoint) return;
      draggingPoint = null;
      syncClosedPoint();
      recomputeBands();
      clearDragReadout();
    }

    el.addEventListener('pointerup', finishDrag);
    el.addEventListener('pointercancel', finishDrag);

    return {
      getCurrentRedData: () => chart.get('lineRed').data.map(p => [p.x, p.y]),
      setRedData: (data) => {
        chart.get('lineRed').setData(data, false);
        syncClosedPoint();
        recomputeBands();
      }
    };
  }

  // ---- Instantiate preview chart ----
  const previewChart = createPolarChart('previewChart', { editable: false, data: redData });
  applyBandVisibility(previewChart);

  function refreshPreview(){
    const bands = deriveBands(redData);
    previewChart.get('lineRed').setData(redData, false);
    previewChart.get('lineOrange').setData(bands.orange, false);
    previewChart.get('lineYellow').setData(bands.yellow, false);

    previewChart.get('fillYellow').setData(toRange(bands.yellow, bands.orange), false);
    previewChart.get('fillOrange').setData(toRange(bands.orange, redData), false);
    previewChart.get('fillRed').setData(toOuterRange(redData), false);
    applyBandVisibility(previewChart);
  }

  function refreshEditorBands(){
    if (!editorChart || !editorApi) return;
    const current = editorApi.getCurrentRedData();
    const bands = deriveBands(current);
    editorChart.get('lineOrange').setData(bands.orange, false);
    editorChart.get('lineYellow').setData(bands.yellow, false);

    editorChart.get('fillYellow').setData(toRange(bands.yellow, bands.orange), false);
    editorChart.get('fillOrange').setData(toRange(bands.orange, current), false);
    editorChart.get('fillRed').setData(toOuterRange(current), false);
    applyBandVisibility(editorChart);
  }

  // Update bands when deltas change
  ['deltaOrange','deltaYellow'].forEach(id => {
    document.getElementById(id).addEventListener('input', () => {
      refreshPreview();
      refreshEditorBands();
    });
  });

  // Band toggles
  document.getElementById('toggleOrange').addEventListener('change', (e) => {
    showOrange = !!e.target.checked;
    refreshPreview();
    refreshEditorBands();
  });
  document.getElementById('toggleYellow').addEventListener('change', (e) => {
    showYellow = !!e.target.checked;
    refreshPreview();
    refreshEditorBands();
  });

  // ---- Modal logic ----
  const backdrop = document.getElementById('modalBackdrop');
  const openBtn = document.getElementById('openEditor');
  const cancelBtn = document.getElementById('cancel');
  const applyBtn = document.getElementById('apply');

  let editorChart = null;
  let editorApi = null;

  function openModal(){
    // In the dialog, don't assume any preset is selected. (Avoids the "always uniform" issue.)
    clearActivePreset();
    // stage current data
    redDataStaged = JSON.parse(JSON.stringify(redData));

    backdrop.style.display = 'flex';
    backdrop.setAttribute('aria-hidden', 'false');

    if (!editorChart){
      editorChart = createPolarChart('editorChart', { editable: true, data: redDataStaged });
      applyBandVisibility(editorChart);
      editorApi = attachManualDrag(editorChart);
      // Ensure readout is reset when opening
      (function(){ const el = document.getElementById('dragValue'); if (el) el.textContent = '—'; })();
    } else {
      editorApi.setRedData(redDataStaged);
      editorChart.reflow();
    }
  }

  function closeModal(){
    backdrop.style.display = 'none';
    backdrop.setAttribute('aria-hidden', 'true');
    redDataStaged = null;
  }

  openBtn.addEventListener('click', openModal);
  cancelBtn.addEventListener('click', () => {
    closeModal();
  });

  applyBtn.addEventListener('click', () => {
    // Applying changes makes the profile effectively "Custom".
    clearActivePreset();
    // Commit staged data from editor
    const current = editorApi.getCurrentRedData();
    // Normalize back to 8+1 so preview stays clean
    const normalized = (function(seriesData){
      const pts = seriesData.map(([x,y]) => ({x,y}));
      // sample nearest at multiples of 45
      const base = [];
      for (let a = 0; a < 360; a += 45){
        let best = pts[0];
        let bestDist = Infinity;
        for (const p of pts){
          const aa = (p.x % 360 + 360) % 360;
          const d = Math.abs(aa - a);
          if (d < bestDist){ best = p; bestDist = d; }
        }
        base.push([a, best.y]);
      }
      return makeClosed(base);
    })(current);

    redData = normalized;
    refreshPreview();
    closeModal();
  });

  backdrop.addEventListener('click', (e) => {
    if (e.target === backdrop) closeModal();
  });

  // ---- Presets and actions (in modal) ----
  function setActivePreset(kind){
    document.querySelectorAll('[data-preset]').forEach(b => b.classList.remove('active'));
    const btn = document.querySelector(`[data-preset="${kind}"]`);
    if (btn) btn.classList.add('active');
  }

  function clearActivePreset(){
    document.querySelectorAll('[data-preset]').forEach(b => b.classList.remove('active'));
  }

  function applyPreset(kind){
    setActivePreset(kind);
    let base;
    if (kind === 'uniform'){
      base = [[0,10],[45,10],[90,10],[135,10],[180,10],[225,10],[270,10],[315,10]];
    } else if (kind === 'south'){
      base = [[0,6],[45,7],[90,9],[135,11],[180,13],[225,11],[270,9],[315,7]];
    } else if (kind === 'north'){
      base = [[0,5],[45,6],[90,8],[135,10],[180,12],[225,10],[270,8],[315,6]];
    } else {
      base = defaultRed8;
    }
    const closed = makeClosed(base);
    editorApi.setRedData(closed);
  }

  function mirrorNS(){
    const data = editorApi.getCurrentRedData();
    // normalize to 8 first
    const pts = data.map(([x,y]) => ({x:(x%360+360)%360, y}));
    const map = new Map();
    for (const p of pts){
      if (p.x === 360) continue;
      map.set(p.x, p.y);
    }
    const out = [];
    for (let a = 0; a < 360; a += 45){
      const mirrored = (180 - a + 360) % 360;
      out.push([a, map.get(mirrored) ?? map.get(a) ?? 10]);
    }
    editorApi.setRedData(makeClosed(out));
  }

  document.getElementById('presetUniform').addEventListener('click', () => applyPreset('uniform'));
  document.getElementById('presetSouthTolerant').addEventListener('click', () => applyPreset('south'));
  document.getElementById('presetNorthStrict').addEventListener('click', () => applyPreset('north'));
  document.getElementById('reset').addEventListener('click', () => applyPreset('reset'));
  document.getElementById('mirrorNS').addEventListener('click', mirrorNS);

</script>
</body>
</html>
